// Generated by gencpp from file cloud_msgs/cloud_info.msg
// DO NOT EDIT!


#ifndef CLOUD_MSGS_MESSAGE_CLOUD_INFO_H
#define CLOUD_MSGS_MESSAGE_CLOUD_INFO_H


#include <string>
#include <vector>
#include <memory>

namespace cloud_msgs
{
template <class ContainerAllocator>
struct cloud_info_
{
  typedef cloud_info_<ContainerAllocator> Type;

  cloud_info_()
    // : header()
    : startRingIndex()
    , endRingIndex()
    , startOrientation(0.0)
    , endOrientation(0.0)
    , orientationDiff(0.0)
    , segmentedCloudGroundFlag()
    , segmentedCloudColInd()
    , segmentedCloudRange()  {
    }
  cloud_info_(const ContainerAllocator& _alloc)
    // : header(_alloc)
    : startRingIndex(_alloc)
    , endRingIndex(_alloc)
    , startOrientation(0.0)
    , endOrientation(0.0)
    , orientationDiff(0.0)
    , segmentedCloudGroundFlag(_alloc)
    , segmentedCloudColInd(_alloc)
    , segmentedCloudRange(_alloc)  {
  (void)_alloc;
    }



   // typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
   // _header_type header;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _startRingIndex_type;
  _startRingIndex_type startRingIndex;

   typedef std::vector<int32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<int32_t>> _endRingIndex_type;
  _endRingIndex_type endRingIndex;

   typedef float _startOrientation_type;
  _startOrientation_type startOrientation;

   typedef float _endOrientation_type;
  _endOrientation_type endOrientation;

   typedef float _orientationDiff_type;
  _orientationDiff_type orientationDiff;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _segmentedCloudGroundFlag_type;
  _segmentedCloudGroundFlag_type segmentedCloudGroundFlag;

   typedef std::vector<uint32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint32_t>> _segmentedCloudColInd_type;
  _segmentedCloudColInd_type segmentedCloudColInd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _segmentedCloudRange_type;
  _segmentedCloudRange_type segmentedCloudRange;





  // typedef boost::shared_ptr< ::cloud_msgs::cloud_info_<ContainerAllocator> > Ptr;
  // typedef boost::shared_ptr< ::cloud_msgs::cloud_info_<ContainerAllocator> const> ConstPtr;

}; // struct cloud_info_

typedef ::cloud_msgs::cloud_info_<std::allocator<void> > cloud_info;

// typedef boost::shared_ptr< ::cloud_msgs::cloud_info > cloud_infoPtr;
// typedef boost::shared_ptr< ::cloud_msgs::cloud_info const> cloud_infoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::cloud_msgs::cloud_info_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::cloud_msgs::cloud_info_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::cloud_msgs::cloud_info_<ContainerAllocator1> & lhs, const ::cloud_msgs::cloud_info_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.startRingIndex == rhs.startRingIndex &&
    lhs.endRingIndex == rhs.endRingIndex &&
    lhs.startOrientation == rhs.startOrientation &&
    lhs.endOrientation == rhs.endOrientation &&
    lhs.orientationDiff == rhs.orientationDiff &&
    lhs.segmentedCloudGroundFlag == rhs.segmentedCloudGroundFlag &&
    lhs.segmentedCloudColInd == rhs.segmentedCloudColInd &&
    lhs.segmentedCloudRange == rhs.segmentedCloudRange;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::cloud_msgs::cloud_info_<ContainerAllocator1> & lhs, const ::cloud_msgs::cloud_info_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace cloud_msgs

#endif // CLOUD_MSGS_MESSAGE_CLOUD_INFO_H
